

---------- THIS IS AN TEXT FILE FOR GIT CODES ----------

GIT INIT - THIS IS USED TO INITIATE A GIT REPOSITIRY IN THE CURRENT LOCATION 
	   IT WILL CREATE A FILE OF .git 

*THERE ARE 3 STAGES OF GIT STATUS*

1) UNTRACKED - IN THIS STAGE IT'S ONLY CREATED AND UNKNOWN TO GIT REPOSITORY
	TO STAGED IT USE git add (file)

2) STAGED - IN THIS IT IS STAGED I.E IT IS KNOWN TO GIT REPO
	USE git commit -m "commit"

	TO SEND IT BACK TO UNTRACKED STATE
	USE git rm --cache (file)

3) TRACKED - IN THIS IT IS SAVED IN GIT REPO AND IT WILL GET A VERSION AUTHOR TO THE FILE
	USE git push -u origin main

git log - THIS SHOWS A commit, author and date at which it is created

git restore --staged (file name) - THIS IS USED TO GET BACK A RM FILE FROM THE GIT REPO TO GIR REPO

git checkout -b (branch name) - THIS CREATES  A NEW BRANCH APART FROM THE MAIN BRANCH SO IT DOSEN'T DISTURBS THE MAIN BRANCH

git switch (branch name) - THIS CAN BE DONE TO CHANGE THE CURRENT IN WORKING BRANCH
OR git checkout (branch name)

git remote -v - IT'S A VARIABLE TO IDENTIFY URL

git revert - IT'S USED TO REVERT A COMMIT GIVEN TO A ADDED FILE

*There are 3 types to do hit reset*

GIT RESET IS A TECH IN WHICH WE CAN REMOVE THE COMMITED FILE

1) SOFT - git reset --soft 
	IN THIS THE COMMIT WHICH HAVE AN ERROR IS UNCOMMITTED AND IS SENT TO STAGED STATE

	I.E 1 -> 2 -> 3 -> 4 -> 
	IN THIS 3 HAVE A PROBLEM WE WILL DO AN GIT RESET --SOFT AT COMMIT 2 AND ALL THE NEXT COMMITED  FILES ARE SENT TO STAGED STATE
	MEANS IT WILL STAY AND WE CAN PUSH IT AGAIN AFTER MAKING CHANGES 

2) MEDIUM - git reset --medium
	IN THIS WE WILL MAKE THE ERROR COMMENT AND ALL THE NEXT COMMENTS TO UNSTAGED STATE

	I.E 1 -> 2 -> 3 -> 4 -> 5
	WE HAVE ERROR AT 3 WE WILL DO GIT RESET --MEDIUM AT 2 COMMIT SO IT MAKES COMMITS FROM 3 AT UNSTAGED
	WE WILL NEED TO DO GIT COMMIT AND THEN PUSH 

3) HARD - git reset --hard
	THIS IS AVOIDED TYPE
	IN THIS ALL THE COMMITS AND THE FILES ARE DELETED

git merge - IT IS USED TO DATE OF OTHER BRANCHES TO MAIN BRANCH OR IN WHICH BRANCH YOU WANT

	I.E :- 	MAIN 1 -> 2 -> 3 -> 
		DEV                 4 -> 5 -> 6

	AFTER MERGE 
		MAIN 1 -> 2 -> 3 -> 4 -> 5 -> 6

git rebase - IT'S SAME AS MERGE BUT IN MERGE IT'S NOT IN A LINER ORDER

	I.E :- MAIN 1 -> 2 ->      7 -> 8 ->
		DEV           3 ->           4 -> 5 -> 6 ->

	AFTER git rebase main
		MAIN 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 


